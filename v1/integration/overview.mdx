---
title: "Integration Overview"
description: "Comprehensive guide to integrating with Urban Management APIs"
---

## Overview

The Urban Management system consists of two main backends that work together to provide a complete urban management solution. This guide covers how to integrate with both systems effectively.

## System Architecture

### Primary Backend
- **Purpose**: Administrative operations and comprehensive data management
- **Port**: 3001
- **Authentication**: Cookie-based JWT with session management
- **Users**: Admin users with role-based permissions
- **Features**: Full CRUD operations, file uploads, complex queries

### Mobile Backend
- **Purpose**: Mobile-optimized operations and user-facing features
- **Port**: 3002
- **Authentication**: Bearer token with phone-based OTP verification
- **Users**: Mobile users (residents, visitors)
- **Features**: Simplified operations, OTP verification, mobile-optimized responses

## Integration Patterns

### Dual Backend Integration

<Mermaid>
graph TB
    subgraph "Client Applications"
        A[Web Dashboard]
        B[Mobile App]
        C[Admin Panel]
    end
    
    subgraph "Backend Services"
        D[Primary Backend<br/>Port 3001]
        E[Mobile Backend<br/>Port 3002]
    end
    
    subgraph "Shared Resources"
        F[Database]
        G[File Storage]
        H[External Services]
    end
    
    A --> D
    C --> D
    B --> E
    
    D --> F
    D --> G
    E --> F
    E --> H
    
    D -.-> E
    E -.-> D
</Mermaid>

### Authentication Flows

#### Admin Authentication (Primary Backend)
```javascript
// Admin login flow
const adminAuth = {
  signIn: async (email, password) => {
    const response = await fetch('http://localhost:3001/api/v1/auth/signin', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ email, password })
    });
    return response.json();
  }
};
```

#### Mobile Authentication (Mobile Backend)
```javascript
// Mobile user authentication flow
const mobileAuth = {
  signIn: async (phoneNumber) => {
    const response = await fetch('http://localhost:3002/api/v1/auth/signin', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ phoneNumber })
    });
    return response.json();
  },
  
  verifyOTP: async (otp, accessToken) => {
    const response = await fetch('http://localhost:3002/api/v1/auth/otp/validate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${accessToken}`
      },
      body: JSON.stringify({ otp })
    });
    return response.json();
  }
};
```

## Data Synchronization

### User Data Flow

<Mermaid>
sequenceDiagram
    participant Mobile
    participant MobileBackend
    participant PrimaryBackend
    participant Database

    Note over Mobile,Database: User Registration Flow
    
    Mobile->>MobileBackend: POST /auth/signin (phone)
    MobileBackend->>Database: findOrCreateUser()
    Database-->>MobileBackend: user data
    MobileBackend-->>Mobile: user + accessToken
    
    Note over Mobile,Database: Admin Management Flow
    
    PrimaryBackend->>Database: GET /users (admin view)
    Database-->>PrimaryBackend: all users
    PrimaryBackend-->>PrimaryBackend: admin operations
    PrimaryBackend->>Database: UPDATE user data
</Mermaid>

### Cross-Backend Communication

While the backends are designed to be independent, they share the same database and can communicate through:

1. **Shared Database**: Both backends access the same data
2. **Event System**: Internal events for data synchronization
3. **API Calls**: Direct API calls between backends when needed

## Client Integration Strategies

### Web Dashboard Integration

```javascript
class UrbanManagementClient {
  constructor() {
    this.primaryAPI = 'http://localhost:3001/api/v1';
    this.mobileAPI = 'http://localhost:3002/api/v1';
  }

  // Admin operations
  async adminSignIn(email, password) {
    const response = await fetch(`${this.primaryAPI}/auth/signin`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ email, password })
    });
    return response.json();
  }

  async getUsers(filters = {}) {
    const params = new URLSearchParams(filters);
    const response = await fetch(`${this.primaryAPI}/users?${params}`, {
      credentials: 'include'
    });
    return response.json();
  }

  // Mobile operations (for admin to view mobile users)
  async getMobileUsers() {
    // This would typically be done through the primary backend
    // which has access to all user data
    return this.getUsers({ source: 'mobile' });
  }
}
```

### Mobile App Integration

```javascript
class MobileAppClient {
  constructor() {
    this.mobileAPI = 'http://localhost:3002/api/v1';
  }

  async signIn(phoneNumber) {
    const response = await fetch(`${this.mobileAPI}/auth/signin`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ phoneNumber })
    });
    return response.json();
  }

  async createOTP(accessToken) {
    const response = await fetch(`${this.mobileAPI}/auth/otp/create`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${accessToken}` }
    });
    return response.json();
  }

  async validateOTP(otp, accessToken) {
    const response = await fetch(`${this.mobileAPI}/auth/otp/validate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${accessToken}`
      },
      body: JSON.stringify({ otp })
    });
    return response.json();
  }

  async getCurrentUser(sessionToken) {
    const response = await fetch(`${this.mobileAPI}/users/current`, {
      headers: { 'Authorization': `Bearer ${sessionToken}` }
    });
    return response.json();
  }
}
```

## Error Handling Strategies

### Unified Error Handling

```javascript
class APIError extends Error {
  constructor(message, code, details = null) {
    super(message);
    this.name = 'APIError';
    this.code = code;
    this.details = details;
  }
}

async function handleAPIResponse(response) {
  const data = await response.json();
  
  if (!response.ok || !data.success) {
    throw new APIError(
      data.error?.message || 'API request failed',
      data.error?.code || 'UNKNOWN_ERROR',
      data.error?.details
    );
  }
  
  return data;
}
```

### Error Recovery Patterns

```javascript
class ResilientAPIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.maxRetries = options.maxRetries || 3;
    this.retryDelay = options.retryDelay || 1000;
  }

  async request(endpoint, options = {}, retryCount = 0) {
    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, options);
      
      if (response.status === 401 && retryCount < this.maxRetries) {
        // Handle token refresh
        await this.refreshToken();
        return this.request(endpoint, options, retryCount + 1);
      }
      
      return await handleAPIResponse(response);
    } catch (error) {
      if (retryCount < this.maxRetries && this.isRetryableError(error)) {
        await this.delay(this.retryDelay * (retryCount + 1));
        return this.request(endpoint, options, retryCount + 1);
      }
      throw error;
    }
  }

  isRetryableError(error) {
    return error.code === 'NETWORK_ERROR' || 
           error.code === 'TIMEOUT' ||
           error.code === 'SERVER_ERROR';
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Performance Optimization

### Caching Strategies

```javascript
class CachedAPIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
  }

  async get(endpoint, options = {}) {
    const cacheKey = `${endpoint}_${JSON.stringify(options)}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.data;
    }
    
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      ...options,
      method: 'GET'
    });
    
    const data = await response.json();
    
    this.cache.set(cacheKey, {
      data,
      timestamp: Date.now()
    });
    
    return data;
  }

  invalidate(pattern) {
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
      }
    }
  }
}
```

### Request Batching

```javascript
class BatchedAPIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.pendingRequests = new Map();
    this.batchDelay = 50; // 50ms
  }

  async batchRequest(endpoint, options = {}) {
    const batchKey = `${endpoint}_${JSON.stringify(options)}`;
    
    if (this.pendingRequests.has(batchKey)) {
      return this.pendingRequests.get(batchKey);
    }
    
    const promise = this.executeRequest(endpoint, options);
    this.pendingRequests.set(batchKey, promise);
    
    // Clear the pending request after completion
    promise.finally(() => {
      this.pendingRequests.delete(batchKey);
    });
    
    return promise;
  }

  async executeRequest(endpoint, options) {
    const response = await fetch(`${this.baseURL}${endpoint}`, options);
    return response.json();
  }
}
```

## Security Considerations

### Token Management

```javascript
class SecureTokenManager {
  constructor() {
    this.tokenRefreshThreshold = 5 * 60 * 1000; // 5 minutes
  }

  async getValidToken() {
    const token = await this.getStoredToken();
    
    if (!token) {
      throw new Error('No token available');
    }
    
    if (this.isTokenExpiringSoon(token)) {
      return await this.refreshToken(token);
    }
    
    return token;
  }

  isTokenExpiringSoon(token) {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expirationTime = payload.exp * 1000;
      const currentTime = Date.now();
      
      return (expirationTime - currentTime) < this.tokenRefreshThreshold;
    } catch {
      return true; // Assume expired if can't parse
    }
  }
}
```

### Input Validation

```javascript
class InputValidator {
  static validatePhoneNumber(phone) {
    const phoneRegex = /^\+[1-9]\d{1,14}$/;
    if (!phoneRegex.test(phone)) {
      throw new Error('Invalid phone number format');
    }
    return phone;
  }

  static validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw new Error('Invalid email format');
    }
    return email;
  }

  static validateUUID(uuid) {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(uuid)) {
      throw new Error('Invalid UUID format');
    }
    return uuid;
  }
}
```

## Testing Strategies

### Integration Testing

```javascript
describe('Urban Management Integration', () => {
  let primaryClient;
  let mobileClient;

  beforeEach(() => {
    primaryClient = new UrbanManagementClient();
    mobileClient = new MobileAppClient();
  });

  describe('Admin Flow', () => {
    it('should allow admin to manage users', async () => {
      // Admin sign in
      const admin = await primaryClient.adminSignIn(
        'admin@example.com',
        'password123'
      );
      expect(admin.id).toBeDefined();

      // Get users
      const users = await primaryClient.getUsers();
      expect(users.data).toBeInstanceOf(Array);
    });
  });

  describe('Mobile Flow', () => {
    it('should allow mobile user authentication', async () => {
      // Mobile sign in
      const mobileUser = await mobileClient.signIn('+1234567890');
      expect(mobileUser.user.id).toBeDefined();

      // Create OTP
      const otpResponse = await mobileClient.createOTP(mobileUser.accessToken);
      expect(otpResponse.message).toContain('OTP sent');

      // Validate OTP (mock)
      const session = await mobileClient.validateOTP('123456', mobileUser.accessToken);
      expect(session.sessionToken).toBeDefined();
    });
  });
});
```

## Deployment Considerations

### Environment Configuration

```javascript
const config = {
  development: {
    primaryBackend: 'http://localhost:3001/api/v1',
    mobileBackend: 'http://localhost:3002/api/v1',
    timeout: 10000
  },
  staging: {
    primaryBackend: 'https://staging-primary.urbanmgmt.com/api/v1',
    mobileBackend: 'https://staging-mobile.urbanmgmt.com/api/v1',
    timeout: 15000
  },
  production: {
    primaryBackend: 'https://api.urbanmgmt.com/v1',
    mobileBackend: 'https://mobile.urbanmgmt.com/v1',
    timeout: 20000
  }
};
```

### Monitoring and Logging

```javascript
class APIMonitor {
  constructor() {
    this.metrics = {
      requestCount: 0,
      errorCount: 0,
      averageResponseTime: 0
    };
  }

  async trackRequest(endpoint, startTime, success) {
    const duration = Date.now() - startTime;
    
    this.metrics.requestCount++;
    if (!success) this.metrics.errorCount++;
    
    this.metrics.averageResponseTime = 
      (this.metrics.averageResponseTime + duration) / 2;
    
    // Send metrics to monitoring service
    await this.sendMetrics({
      endpoint,
      duration,
      success,
      timestamp: new Date().toISOString()
    });
  }
}
```

## Next Steps

- [Authentication Flows](/v1/integration/authentication-flows)
- [Error Handling](/v1/integration/error-handling)
- [Rate Limiting](/v1/integration/rate-limiting)
